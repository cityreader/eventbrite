<?php

define('EVENTBRITE_EVENT_PRIVATE', 0);
define('EVENTBRITE_EVENT_PUBLIC', 1);


module_load_include('inc', 'eventbrite_event', 'includes/eventbrite_event.forms');

/**
 * Implements hook_entity_info().
 */
function eventbrite_event_entity_info() {
  $entities['eventbrite_event'] = array(
    'label' => t('Event'),
    'entity class' => 'EventbriteEvent',
    'controller class' => 'EntityAPIController',
    'base table' => 'eventbrite_event',
    'fieldable' => TRUE,
    'bundles' => array(
      'eventbrite_event' => array(
        'label' => t('Eventbrite Event'),
        'admin' => array(
          'path' => 'admin/content/events',
          'access arguments' => array('administer eventbrite events'),
        ),
      ),
    ),
    'entity keys' => array(
      'id' => 'event_id',
      'label' => 'title',
    ),
    'view modes' => array(
      'full' => array(
        'label' => t('Full content'),
        'custom settings' => FALSE,
      ),
      'teaser' => array(
        'label' => t('Teaser'),
        'custom settings' => TRUE,
      ),
    ),
    'label callback' => 'entity_class_label',
    'uri callback' => 'entity_class_uri',
    'module' => 'eventbrite_event',
    'metadata controller class' => 'EventbriteEventMetadataController',
    'admin ui' => array(
      'path' => 'admin/content/events',
      'file path' => drupal_get_path('module', 'eventbrite') . '/includes',
      'file' => 'eventbrite_event.forms.inc',
      'controller class' => 'EventbriteEventUIController',
    ),
    'access callback' => 'eventbrite_access',
  );

  $entities['eventbrite_ticket'] = array(
    'label' => t('Event'),
    'entity class' => 'EventbriteTicket',
    'controller class' => 'EntityAPIController',
    'base table' => 'eventbrite_ticket',
    'fieldable' => FALSE,
    'bundles' => array(
      'eventbrite_ticket' => array(
        'label' => t('Eventbrite Ticket'),
        // 'admin' => array(
          // 'path' => 'admin/content/events',
          // 'access arguments' => array('administer eventbrite events'),
        // ),
      ),
    ),
    'entity keys' => array(
      'id' => 'ticket_id',
      'label' => 'title',
    ),
    'view modes' => array(
      'full' => array(
        'label' => t('Full content'),
        'custom settings' => FALSE,
      ),
    ),
    'label callback' => 'entity_class_label',
    'uri callback' => 'entity_class_uri',
    'module' => 'eventbrite_event',
    'access callback' => 'eventbrite_access',
  );

  return $entities;
}

/**
 * Implements hook_entity_info_alter().
 */
// function eventbrite_event_entity_info_alter(&$info) {
  // if (isset($info['eventbrite_event'])) {
     // // Add or remove the body field, as needed.
//      
    // $field = field_info_field('tickets');
//     
    // $instance = field_info_instance('eventbrite_event', 'tickets', 'eventbrite_event');
//     
    // if (empty($field)) {
      // $field = array(
        // 'field_name' => 'tickets',
        // 'type' => 'eventbrite_ticket',
        // 'module' => 'eventbrite',
        // 'cardinality' => FIELD_CARDINALITY_UNLIMITED,
        // 'entity_types' => array('eventbrite_event'),
      // );
//        
      // $field = field_create_field($field);
    // }
// 
    // if (empty($instance)) {
//       
      // $instance = array(
        // 'field_name' => 'tickets',
        // 'entity_type' => 'eventbrite_event',
        // 'bundle' => 'eventbrite_event',
        // 'label' => 'Tickets',
        // 'settings' => array(),
        // 'description' => 'Event ticket field',
        // 'required' => TRUE,
        // 'widget' => array(
          // 'type' => 'eventbrite_ticket_widget',
        // ),
        // 'display' => array(
          // 'default' => array(
            // 'type' => 'eventbrite_ticket_formatter',
            // 'weight' => 10,
          // ),
          // 'teaser' => array(
            // 'type' => 'eventbrite_ticket_formatter',
            // 'weight' => 10,
          // ),
        // ),
      // ); 
//   
      // $instance = field_create_instance($instance);
    // }
  // }
// }

/**
 * Implements hook_menu().
 */
function eventbrite_event_menu() {
  $eventbrite_event_uri = eventbrite_event_uri();
  $id_count = count(explode('/', $eventbrite_event_uri));

  $items['eventbrite/ajax'] = array(
    'page callback' => 'eventbrite_ticket_remove_js',
    'delivery callback' => 'ajax_deliver',
    'access arguments' => array('administer eventbrite settings'),
    'theme callback' => 'ajax_base_page_theme',
    'file path' => drupal_get_path('module', 'eventbrite') . '/includes',
    'file' => 'eventbrite.field.inc',
    'type' => MENU_CALLBACK,
  );

  $items[$eventbrite_event_uri . '/%eventbrite_event'] = array(
    'title callback' => 'eventbrite_event_page_title',
    'title arguments' => array($id_count),
    'page callback' => 'eventbrite_event_page_view',
    'page arguments' => array($id_count),
    'access arguments' => array('view eventbrite events'),
    'file path' => drupal_get_path('module', 'eventbrite_event') . '/includes',
    'file' => 'eventbrite_event.pages.inc',
    'type' => MENU_CALLBACK,
  );

  $items[$eventbrite_event_uri . '/%eventbrite_event/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  
  // $items[$eventbrite_event_uri . '/%eventbrite_event/edit'] = array(
    // 'title' => 'Edit',
    // 'page callback' => 'eventbrite_contextual_page_tab',
    // 'page arguments' => array($id_count, 'eventbrite_event'),
    // 'access arguments' => array('administer eventbrite events'),
    // 'file path' => drupal_get_path('module', 'eventbrite_event') . '/includes',
    // 'file' => 'eventbrite_event.pages.inc',
    // 'type' => MENU_LOCAL_TASK,
  // );

  $items['eventbrite/event_refresh'] = array(
    'title' => 'Event Fefresh',
    'page callback' => 'eventbrite_event_refresh_page',
    'access arguments' => array('administer eventbrite settings'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_theme().
 */
function eventbrite_event_theme() {
  $path = drupal_get_path('module', 'eventbrite_event');
  return array(
    'eventbrite_event' => array(
      'render element' => 'elements',
      'template' => 'eventbrite-event',
      'path' => $path . '/themes',
      'file' => 'theme.inc',
    ),
    'eventbrite_event_ticket' => array(
      'render element' => 'element',
      'path' => $path . '/themes',
      'file' => 'theme.inc',
    ),
    'eventbrite_event_venue' => array(
      'variables' => array('venue' => NULL),
      'template' => 'eventbrite-event-venue',
      'path' => $path . '/themes',
    ),
//    'eventbrite_organizer_list_form' => array(
//      'render element' => 'form',
//      'file' => 'eventbrite.organizer.inc',
//    ),
  );
}

/**
 * Eventbrite event loader.
 *
 * @param $id
 *   (optional) The internal id for this event. If no id is given all existing
 *   events are returned.
 *
 * @return EventbriteVenue
 *   Returns a fully-loaded Eventbrite event definition.
 */
function eventbrite_event_load($id) {
  return entity_load_single('eventbrite_event', $id);
}

/**
 * Load multiple Eventbrite event entities based on certain conditions.
 *
 * @param $ids
 *   An array of Eventbrite event internal IDs of Drupal.
 * @param $conditions
 *   An array of conditions to match against the {entity} table.
 * @param $reset
 *   A boolean indicating that the internal cache should be reset.
 *
 * @return
 *   An array of event entities, indexed by event ID.
 */
function eventbrite_event_load_multiple($ids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('eventbrite_event', $ids, $conditions, $reset);
}

/**
 * Saves an Eventbrite event to the database.
 *
 * @param EventbriteVenue $event
 *   The event object.
 */
function eventbrite_event_save($event) {  
  return $event->save();
}

/**
 * Return event page base link to enable others to modify it
 */
function eventbrite_event_uri() {
  return variable_get('eventbrite_event_uri', 'event');
}

/**
 * Implements hook_field_extra_fields()
 */
function eventbrite_event_field_extra_fields() {
  $extra['eventbrite_event']['eventbrite_event'] = array(
    'form' => array(
      'description' => array(
        'label' => t('Event Details'),
        'description' => t('Event entity element'),
        'weight' => -4,
      ),
      // 'tickets' => array(
        // 'label' => t('Ticket Information'),
        // 'description' => t('Event entity element'),
        // 'weight' => -3,
      // ),
    ),
    'display' => array(
      'tickets' => array(
        'label' => t('Ticket Information'),
        'description' => t('Event entity element'),
        'weight' => 0,
      ),
      'description' => array(
        'label' => t('Event Details'),
        'description' => t('Event entity element'),
        'weight' => 1,
      ),
    )
  );

  return $extra;
}

function eventbrite_event_refresh_page() {
  $expire = variable_get('eventbrite_cron', 60);

  $result = db_query('SELECT * FROM {eventbrite_organizer} WHERE queued = 0 OR queued < :time', array(
    ':time' => REQUEST_TIME - $expire
  ));

  if (!$result) {
    return;
  }

  $queue = DrupalQueue::get('eventbrite_event');
  foreach ($result as $organizer) {
    
    $params = array(
      'id' => $organizer->organizer_id,
    );
    
    $result = eventbrite_get('organizer_list_events', $params, TRUE);
    
    if (!$result) {
      continue;
    }

    foreach ($result->events as $event) {
      // db_update('eventbrite_organizer')
        // ->fields(array('queued' => REQUEST_TIME))
        // ->condition('id', $organizer->id)
        // ->execute();
      
      $ebo_event = $event->event;
      eventbrite_event_refresh($ebo_event);
      // $queue->createItem($ebo_event);
    }
  }
  return 'hello';
}

/**
 * Implements hook_cron().
 *
 * Queues news feeds for updates once their refresh interval has elapsed.
 */
function eventbrite_event_cron() {
  $cron = variable_get('eventbrite_cron', 84600);
  
  $result = db_query('SELECT * FROM {eventbrite_organizer} WHERE queued = 0 OR queued < :time', array(
    ':time' => REQUEST_TIME - $cron
  ));
    dpm($result);
  if (!$result) {
    return;
  }

  $queue = DrupalQueue::get('eventbrite_event');

  foreach ($result as $organizer) {
    db_update('eventbrite_organizer')
      ->fields(array('queued' => REQUEST_TIME))
      ->condition('id', $organizer->id)
      ->execute();

    $params = array(
      'id' => $organizer->organizer_id,
    );

    $result = eventbrite_get('organizer_list_events', $params, TRUE);

    if (!$result) {
      continue;
    }

    foreach ($result->events as $event) {     
      $ebo_event = $event->event;
      eventbrite_event_refresh($ebo_event);

      $queue->createItem($ebo_event);
    }
    
    dpm($events);
  }
  
  
  // $result = db_query('SELECT * FROM {aggregator_feed} WHERE queued = 0 AND checked + refresh < :time AND refresh <> :never', array(
    // ':time' => REQUEST_TIME,
    // ':never' => AGGREGATOR_CLEAR_NEVER
  // ));
  // $queue = DrupalQueue::get('aggregator_feeds');
  // foreach ($result as $feed) {
    // if ($queue->createItem($feed)) {
      // // Add timestamp to avoid queueing item more than once.
      // db_update('aggregator_feed')
        // ->fields(array('queued' => REQUEST_TIME))
        // ->condition('fid', $feed->fid)
        // ->execute();
    // }
  // }
// 
  // // Remove queued timestamp after 6 hours assuming the update has failed.
  // db_update('aggregator_feed')
    // ->fields(array('queued' => 0))
    // ->condition('queued', REQUEST_TIME - (3600 * 6), '<')
    // ->execute();
}

/**
 * Implements hook_cron_queue_info().
 */
function eventbrite_event_cron_queue_info() {
  $queues['eventbrite_event'] = array(
    'worker callback' => 'eventbrite_event_refresh',
    'time' => 60,
  );
  return $queues;
}

/**
 * Checks a news feed for new items.
 *
 * @param $feed
 *   An object describing the feed to be refreshed.
 */
function eventbrite_event_refresh($ebo_event) {
  $event_id = db_select('eventbrite_event', 'e')
    ->fields('e', array('event_id'))
    ->condition('id', $ebo_event->id)
    ->execute()
    ->fetchField();

  if ($event_id) {
    // Check existing event and update
    $event = eventbrite_event_load($event_id);

    $modified = strtotime($ebo_event->modified + ' ' + $ebo_event->timezone_offset);

    if ($event->modified != $modified) {
      $event->title = $ebo_event->title;
      $event->description = $ebo_event->description;
      $event->status = $ebo_event->status;
      $event->venue_id = eventbrite_event_get_venue_id($ebo_event->venue, $event);
      $event->organizer_id = $ebo_event->organizer->id;
      $event->start_date = strtotime($ebo_event->start_date + ' ' + $ebo_event->timezone_offset);
      $event->end_date = strtotime($ebo_event->end_date + ' ' + $ebo_event->timezone_offset);
      $event->privacy = $ebo_event->privacy;
      $event->modified = strtotime($ebo_event->modified + ' ' + $ebo_event->timezone_offset);

      eventbrite_event_save($event);
    }
  }
  else {
    // Create new event entity 
    $event = array(
      'id' => $ebo_event->id,
      'title' => $ebo_event->title,
      'description' => $ebo_event->description,
      'venue_id' => eventbrite_event_get_venue_id($ebo_event->venue),
      'organizer_id' => $ebo_event->organizer->id,
      'status' => $ebo_event->status,
      'start_date' => strtotime($ebo_event->start_date + ' ' + $ebo_event->timezone_offset),
      'end_date' => strtotime($ebo_event->end_date + ' ' + $ebo_event->timezone_offset),
      'privacy' => $ebo_event->privacy,
      'created' => strtotime($ebo_event->created + ' ' + $ebo_event->timezone_offset),
      'modified' => strtotime($ebo_event->modified + ' ' + $ebo_event->timezone_offset),
    );
    $event = entity_create('eventbrite_event', $event);
    eventbrite_event_save($event);
  }
}

/**
 * Get venue ID from returned object via API
 * 
 * It will capture a new venue or use an venue existing in the database
 * 
 * Notice: It is not necessary to update venue info, as Eventbrite will create a venue 
 * when users update venue information in the Eventbrite website.
 * 
 * @param $ebo_venue
 *   The venue object returned back from Eventbrite via API.
 * @param $event
 *   The eventbrite_event entity.
 * @return
 *   The venue entity ID which is as same of eventbrite venue ID.
 */
function eventbrite_event_get_venue_id($ebo_venue, $event = NULL) {
  if ($event && $event->venue_id == $ebo_venue->id) {
    return $event->venue_id;
  }

  $number = db_query('SELECT COUNT(*) FROM {eventbrite_venue} WHERE venue_id = :venue_id', array(
    ':venue_id' => $ebo_venue->id))
    ->fetchField();

  if ($number > 0) {
    return $ebo_venue->id;
  }
  else {
    // Create new venue entity
    $venue = array(
      'venue_id' => $ebo_venue->id,
      'name' => $ebo_venue->name,
      'address' => $ebo_venue->address,
      'address_2' => $ebo_venue->address_2,
      'city' => $ebo_venue->city,
      'region' => $ebo_venue->region,
      'country_code' => $ebo_venue->country_code,
      'postal_code' => $ebo_venue->postal_code,
      'longitude' => $ebo_venue->longitude,
      'latitude' => $ebo_venue->latitude,
    );

    $venue = entity_create('eventbrite_venue', $venue);
    eventbrite_venue_save($venue);

    return $venue->venue_id;
  }
}

function eventbrite_event_privacy_options() {
  return array(
    EVENTBRITE_EVENT_PRIVATE => t('Private event'),
    EVENTBRITE_EVENT_PUBLIC => t('Public event'),
  );
}

function eventbrite_event_preprocess_eventbrite_event_venue(&$variables) {
  $venue = $variables['venue'];

  $address = array();
  
  foreach (array('addess', 'address_2', 'city', 'region') as $field_name) {
    if (!empty($venue->$field_name)) {
      $address[] = $venue->$field_name;
    }
  }
  $address = implode(', ', $address);

  $variables['address'] = check_plain($address);
  $variables['name'] = check_plain($venue->name);
}




