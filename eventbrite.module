<?php

/**
 * @file
 * Eventbrite module.
 */

define('EVENTBRITE_URL_ORG', 'http://www.eventbrite.com/org');

module_load_include('inc', 'eventbrite', 'includes/eventbrite.date');
module_load_include('inc', 'eventbrite', 'includes/eventbrite.field');

/**
 * Implements hook_libraries_info().
 */
function eventbrite_libraries_info() {
  // A very simple library. No changing APIs (hence, no versions), no variants. 
  $libraries['eventbrite.php'] = array(
    'name' => 'PHP Eventbrite API Client Library',
    'vendor url' => 'http://developer.eventbrite.com/doc/libraries',
    'download url' => 'https://github.com/ryanjarvinen/eventbrite.php.git',
    'files' => array(
      'php' => array('Eventbrite.php'),
    ),
    'version' => '1.0',
    'error message' => t('Download PHP Eventbrite API Client Library'),
  );

  return $libraries;
}

/**
 * Implements hook_init().
 */
function eventbrite_init() {
  drupal_add_css(drupal_get_path('module', 'eventbrite') . '/eventbrite.css');
}

/**
 * Implements of hook_menu().
 */
function eventbrite_menu() {
  //Field API autocomplete
  $items['eventbrite/autocomplete'] = array(
    'title' => 'Time zone field autocomplete',
    'page callback' => 'eventbritefield_autocomplete',
    'access arguments' => array('access content'),
    'file path' => drupal_get_path('module', 'eventbrite') . '/includes',
    'file' => 'eventbrite.field.inc',
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/services/eventbrite'] = array(
    'title' => 'Eventbrite Configuration',
    'description' => 'Configure Eventbrite settings & objects',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('eventbrite_admin_settings'),
    'access arguments' => array('administer eventbrite settings'),
    'file path' => drupal_get_path('module', 'eventbrite') . '/includes',
    'file' => 'eventbrite.admin.inc',
  );

  $items['admin/config/services/eventbrite/api'] = array(
    'title' => 'API Settings',
    'description' => 'Configure Eventbrite API settings',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -1,
  );

  $items['admin/config/services/eventbrite/payment-settings'] = array(
    'title' => 'Payment Settings',
    'description' => 'Configure default payment settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('eventbrite_payment_admin_settings', TRUE),
    'access arguments' => array('administer eventbrite settings'),
    'file path' => drupal_get_path('module', 'eventbrite') . '/includes',
    'file' => 'eventbrite.payment.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 5,
  );

  return $items;
}

/**
 * Implements hook_entity_info().
 */
function eventbrite_entity_info() {
  $entities['eventbrite_event'] = array(
    'label' => t('Event'),
    'entity class' => 'EventbriteEvent',
    'controller class' => 'EntityAPIController',
    'base table' => 'eventbrite_event',
    'fieldable' => TRUE,
    'bundles' => array(
      'eventbrite_event' => array(
        'label' => t('Eventbrite Event'),
        'admin' => array(
          'path' => 'admin/config/services/eventbrite/events',
          'access arguments' => array('administer eventbrite events'),
        ),
      ),
    ),
    'entity keys' => array(
      'id' => 'id',
      'label' => 'title',
    ),
    'view modes' => array(
      'full' => array(
        'label' => t('Full content'),
        'custom settings' => FALSE,
      ),
      'teaser' => array(
        'label' => t('Teaser'),
        'custom settings' => TRUE,
      ),
    ),
    'label callback' => 'entity_class_label',
    'uri callback' => 'entity_class_uri',
    'module' => 'eventbrite',
    'admin ui' => array(
      'path' => 'admin/config/services/eventbrite/events',
      'file path' => drupal_get_path('module', 'eventbrite') . '/includes',
      'file' => 'eventbrite.event.inc',
      'controller class' => 'EventbriteEventUIController',
    ),
    'access callback' => 'eventbrite_access',
  );
  
  $entities['eventbrite_venue'] = array(
    'label' => t('Venue'),
    'entity class' => 'EventbriteVenue',
    'controller class' => 'EntityAPIController',
    'base table' => 'eventbrite_venue',
    'fieldable' => TRUE,
//    'view modes' => array(
//      'full' => array(
//        'label' => t('Full content'),
//        'custom settings' => FALSE,
//      ),
//      'teaser' => array(
//        'label' => t('Teaser'),
//        'custom settings' => TRUE,
//      ),
//    ),
    'bundles' => array(
      'eventbrite_venue' => array(
        'label' => t('Eventbrite Venue'),
        'admin' => array(
          'path' => 'admin/config/services/eventbrite/venues',
          'access arguments' => array('administer eventbrite events'),
        ),
      ),
    ),
    'entity keys' => array(
      'id' => 'venue_id',
      'label' => 'name',
    ),
    'label callback' => 'entity_class_label',
    'uri callback' => 'entity_class_uri',
    'module' => 'eventbrite',
    // Enable the entity API's admin UI.
    'admin ui' => array(
      'path' => 'admin/config/services/eventbrite/venues',
      'file path' => drupal_get_path('module', 'eventbrite') . '/includes',
      'file' => 'eventbrite.venue.inc',
      'controller class' => 'EventbriteVenueUIController',
    ),
    'access callback' => 'eventbrite_access',
  );

  $entities['eventbrite_organizer'] = array(
    'label' => t('Organizer'),
    'entity class' => 'EventbriteOrganizer',
    'controller class' => 'EntityAPIController',
    'base table' => 'eventbrite_organizer',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'id',
      'label' => 'name',
    ),
//    'bundles' => array(
//      'eventbrite_organizer' => array(
//        'label' => t('Eventbrite Organizer'),
//      ),
//    ),
//    'view modes' => array(
//      'full' => array(
//        'label' => t('Full content'),
//        'custom settings' => FALSE,
//      ),
//      'teaser' => array(
//        'label' => t('Teaser'),
//        'custom settings' => TRUE,
//      ),
//    ),
    'label callback' => 'entity_class_label',
    'uri callback' => 'entity_class_uri',
    'module' => 'eventbrite',
    // Enable the entity API's admin UI.
    'admin ui' => array(
      'path' => 'admin/config/services/eventbrite/organizers',
      'file path' => drupal_get_path('module', 'eventbrite') . '/includes',
      'file' => 'eventbrite.organizer.inc',
      'controller class' => 'EventbriteOrganizerUIController',
    ),
    'access callback' => 'eventbrite_access',
  );
  
  return $entities;
}

/**
 * Implements hook_entity_info_alter().
 */
function eventbrite_entity_info_alter(&$info) {
  if (isset($info['eventbrite_event'])) {
     // Add or remove the body field, as needed.
     
    $field = field_info_field('tickets');
    
    $instance = field_info_instance('eventbrite_event', 'tickets', 'eventbrite_event');
    
    if (empty($field)) {
      $field = array(
        'field_name' => 'tickets',
        'type' => 'eventbrite_ticket',
        'module' => 'eventbrite',
        'cardinality' => FIELD_CARDINALITY_UNLIMITED,
        'entity_types' => array('eventbrite_event'),
      );
       
      $field = field_create_field($field);
    }

    if (empty($instance)) {
      
      $instance = array(
        'field_name' => 'tickets',
        'entity_type' => 'eventbrite_event',
        'bundle' => 'eventbrite_event',
        'label' => 'Tickets',
        'settings' => array(),
        'description' => 'Event ticket field',
        'required' => TRUE,
        'widget' => array(
          'type' => 'eventbrite_ticket_widget',
        ),
        'display' => array(
          'default' => array(
            'type' => 'eventbrite_ticket_formatter',
            'weight' => 10,
          ),
          'teaser' => array(
            'type' => 'eventbrite_ticket_formatter',
            'weight' => 10,
          ),
        ),
      ); 
  
      $instance = field_create_instance($instance);
    }
  }
}

/**
 * Implements hook_permissions().
 */
function eventbrite_permission() {
  return array(
    'administer eventbrite settings' => array(
      'title' => t('administer eventbrite settings'),
      'description' => t('Gives full control over the eventbrite admin page'),
    ),
    'administer eventbrite events' => array(
      'title' => t('administer eventbrite events'),
      'description' => t('allows users to configure eventbrite events'),
    ),
  );
}

/**
 * Access check for Eventbrite admin UI page
 */
function eventbrite_access($op, $entity = NULL, $account = NULL, $entity_type) {
  switch ($entity_type) {
    case 'eventbrite_event':
      return user_access('administer eventbrite events', $account);
    
    case 'eventbrite_venue':
      return user_access('administer eventbrite settings', $account);
     
    case 'eventbrite_organizer':
      return user_access('administer eventbrite settings', $account);
  }

  // if ($op == 'create' || $op == 'update') {
  //   $op = 'edit';
  // }
  // Allow modules to grant / deny access.
  return FALSE;
}


/**
 * Implements hook_theme().
 */
function eventbrite_theme() {
  return array(
//    'eventbrite_venue_list_form' => array(
//      'render element' => 'form',
//      'file' => 'eventbrite.venue.inc',
//    ),
//    'eventbrite_organizer_list_form' => array(
//      'render element' => 'form',
//      'file' => 'eventbrite.organizer.inc',
//    ),
  );
}

/**
 * Implements hook_flush_caches().
 */
function eventbrite_flush_caches() {
  return array('cache_eventbrite');
}

/* API FUNCTIONS EXPOSED TO OTHER MODULES */

/**
 * Get $eb_client instance
 */
function eventbrite_get_object($app_key = '', $user_key = '') {
  static $eb_client;

  if (empty($eb_client) && eventbrite_is_valid_auth()) {
        
    libraries_load('eventbrite.php');

    $authentication_tokens = array(
      'app_key'  => $app_key ? $app_key : variable_get('eventbrite_app_key', ''),
      'user_key' => $user_key ? $user_key : variable_get('eventbrite_user_key', ''),
    );

    $eb_client = new Eventbrite($authentication_tokens); 
  }

  return $eb_client;
}

function eventbrite_debug_message($message) {
  if (variable_get('eventbrite_debug', 0)) {
    if (module_exists('devel')) {
      dpm($message);
    }
    else {
      $message = '<pre>' . print_r($message, TRUE) . '</pre>';
      drupal_set_message($message);
    }
  }
}

/**
 * Allows a get-oriented operation to called via the Eventbrite API
 *
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function eventbrite_get($op, $params = NULL, $reset = FALSE) {
  $result = array();

  $eb_client = eventbrite_get_object();

  if (!$eb_client) {
    return FALSE;
  }

  $valid_callbacks = array(
    // Events
    'event_get',
    // Organizers
    'organizer_get',
    // Users
    'user_list_events',
    'user_list_venues',
    'user_list_organizers',
    'user_get',
  );

  if (!in_array($op, $valid_callbacks)) {
    drupal_set_message('Eventbrite get operation is not valid', 'error');
    watchdog('eventbrite', t('Eventbrite get operation is not valid'), NULL, WATCHDOG_ERROR);
    return;
  }


  $user_key = variable_get('eventbrite_user_key', '');
  $cid = $op . ':' . $user_key;
  $cache = FALSE;

  if ($reset) {
    clear_cache_all($cid, 'cache_eventbrite');
  }
  else {
    $cache = cache_get($cid, 'cache_eventbrite');
  }

  if ($cache !== FALSE && REQUEST_TIME <= $cache->expire) {
    $result = $cache->data;
  }
  else {
    try{
      $result = $eb_client->$op($params);

      eventbrite_debug_message($result);

    } catch (Exception $e) {
      drupal_set_message('Eventbrite API call failed. Error message:' . "\n" . $e->getMessage(), 'error');
      watchdog('eventbrite', 'Eventbrite API call failed. Error message:' . "\n" . $e->getMessage(), NULL, WATCHDOG_ERROR);
      return;
    }

    if (strpos($op, 'user_list') !== FALSE) {
      $plural_label = substr($op, 10);
      $label = substr($op, 10, -1);
      $data = array();

      foreach ($result->$plural_label as $object) {
        $entry = $object->$label;
        $id_key = $label . '_id';

        $entry->$id_key = (string) $entry->id;

        unset($entry->id);

        $data[$entry->$id_key] = $entry;
      }

      $result = $data;

      module_invoke_all('eventbrite_' . $op, $result);

      $expire = 60 * variable_get('eventbrite_cache_minimum', 5);

      cache_set($cid, $data, 'cache_eventbrite', REQUEST_TIME + $expire);
    }
  }

  return $result;
}

/**
 * Implements hook_eventbrite_user_list_organizers()
 */
function eventbrite_eventbrite_user_list_organizers($result) {

  $remote_organizer_ids = $result;
  $organizer_ids = db_query('SELECT organizer_id, id FROM {eventbrite_organizer}')->fetchAllKeyed();

  $new_organizer_ids = array_diff_key($remote_organizer_ids, $organizer_ids);

  $update_organizer_ids = array_intersect_key($organizer_ids, $remote_organizer_ids);

  foreach($new_organizer_ids as $organizer_id => $entry) {
    $organizer = eventbrite_organizer_create($entry);

    eventbrite_organizer_save($organizer);
  }

  foreach($update_organizer_ids as $organizer_id => $entity_id) {
    $organizer = eventbrite_organizer_load($entity_id);
    $entry = $result[$organizer_id];

    $organizer->name = $entry->name;
    $organizer->description = $entry->description;

    eventbrite_organizer_save($organizer);
  }
}

/**
 * Implements hook_eventbrite_user_list_venues()
 */
function eventbrite_eventbrite_user_list_venues($result) {
  $remote_venue_ids = $result;
  $venue_ids = db_query('SELECT venue_id FROM {eventbrite_venue}')->fetchCol();

  $venue_ids = empty($venue_ids) ? array() : array_flip($venue_ids);

  $new_venue_ids = array_diff_key($remote_venue_ids, $venue_ids);

  $update_venue_ids = array_keys(array_intersect_key($venue_ids, $remote_venue_ids));

  foreach($new_venue_ids as $venue_ids => $entry) {
    $venue = eventbrite_venue_create($entry);

    eventbrite_venue_save($venue);
  }

  foreach($update_venue_ids as $venue_ids) {
    $venue = eventbrite_venue_load($venue_ids);
    $entry = $result[$venue_ids];

    $venue->name = $entry->name;
    $venue->address = $entry->address;
    $venue->address_2 = $entry->address_2;
    $venue->city = $entry->city;
    $venue->region = $entry->region;
    $venue->postal_code = $entry->postal_code;
    $venue->country_code = $entry->country_code;

    eventbrite_venue_save($venue);
  }
}

/*
 * Allows a save-oriented operation to called via the Eventbrite API
 */
/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function eventbrite_save($op, $params) {
  $result = array();

  $eb_client = eventbrite_get_object();

  if (!$eb_client) {
    return FALSE;
  }

  $valid_callbacks = array(
    // Events
    'event_new',
    'event_update',
    // Tickets
    'ticket_new',
    'ticket_update',
    // Venues
    'venue_new',
    'venue_update',
    // Organizer Profiles
    'organizer_new',
    'organizer_update',
    // Users
    'user_new',
    // Payments
    'payment_update',
  );

  if (!in_array($op, $valid_callbacks)) {
    drupal_set_message('Eventbrite save operation is not valid', 'error');
    watchdog('eventbrite', t('Eventbrite save operation is not valid'), NULL, WATCHDOG_ERROR);
    return;
  }

  try{
    $result = $eb_client->$op($params);

    eventbrite_debug_message($result);
  } catch (Exception $e) {
    drupal_set_message('Eventbrite API call failed. Error message:' . "\n" . $e->getMessage(), 'error');
    watchdog('eventbrite', 'Eventbrite API call failed. Error message:' . "\n" . $e->getMessage(), NULL, WATCHDOG_ERROR);
    return;
  }

//  module_invoke_all('eventbrite_' . $op, $result);

  return $result;
}

/**
 * Synchronize local data with remote Eventbrite data
 */
function eventbrite_sync($op) {
  eventbrite_get($op);
}

/*
 * This function translates offset into the formatting that Eventbrite API is expecting
 */
/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function eventbrite_timezone_offset($offset) {
  $eb_timezone = 'GMT';
  $eb_timezone .= ($offset < 0) ? '-' : '+';
  $eb_timezone .= (abs($offset) >= 10) ? abs($offset) : '0' . abs($offset);

  return $eb_timezone;
}

/**
 * Returns Eventbrite's API user_list_events as a keyed array suitable
 * for option lists.
 *
 * @param mixed $id
 *   The event id for an event that must not be filtered.
 * @param boolean $allow_historical
 *   Whether or not events that start prior to the current time should
 *   be returned.
 * @return array
 *   An array of events keyed by event id and containing event titles.
 */
function eventbrite_get_events_options($id = null, $allow_historical = false) {
  $options = array();
  if ($events = eventbrite_get('user_list_events')) {
    $options[0] = '';
    foreach ($events as $event_id => $event) {
      if (($id == $event_id) || $allow_historical) {
        $options[$event_id] = $event->title;
      }
      else {
        $start_date_ts = date_convert($event->start_date, DATE_DATETIME, DATE_UNIX, $event->timezone);
        if ($start_date_ts > REQUEST_TIME) {
          $options[$event_id] = $event->title;
        }
      }
    }
  }
  return $options;
}


/*
 * This function returns TRUE if Eventbrite module is set up with valid Eventbrite authentication
 */
/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function eventbrite_is_valid_auth() {
  return variable_get('eventbrite_is_valid_auth', FALSE);
}



/**
 * Eventbrite event loader.
 *
 * @param $id
 *   (optional) The internal id for this event. If no id is given all existing
 *   events are returned.
 *
 * @return EventbriteVenue
 *   Returns a fully-loaded Eventbrite event definition.
 */
function eventbrite_event_load($id) {
  return entity_load_single('eventbrite_event', $id);
}

/**
 * Load multiple Eventbrite event entities based on certain conditions.
 *
 * @param $ids
 *   An array of Eventbrite event internal IDs of Drupal.
 * @param $conditions
 *   An array of conditions to match against the {entity} table.
 * @param $reset
 *   A boolean indicating that the internal cache should be reset.
 *
 * @return
 *   An array of event entities, indexed by event ID.
 */
function eventbrite_event_load_multiple($ids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('eventbrite_event', $ids, $conditions, $reset);
}

/**
 * Create a Eventbrite event object.
 */
function eventbrite_event_create($values = array()) {
  if (is_object($values)) {
    $values = (array) $values;
  }

  return entity_get_controller('eventbrite_event')->create($values);
}

/**
 * Saves an Eventbrite event to the database.
 *
 * @param EventbriteVenue $event
 *   The event object.
 */
function eventbrite_event_save(EventbriteVenue $event) {
  return $event->save();
}


/**
 * The class used for Eventbrite organizer entities.
 */
class EventbriteEvent extends Entity {

  public $event_id;
  public $title;
  public $description;
  public $description_format;
  public $start_date;
  public $end_date;
  public $privacy;
  public $personalized_url;
  public $venue_id;
  public $organizer_id;
  public $capacity;
  public $status;
  public $created;
  public $modified;
  public $tickets;

  public function defaultLabel() {
    return $this->title;
  }

  /**
   * Overrides Entity::save().
   */
  public function save() {
    // Only save data remotely to Eventbrite in a form submission 
    if (isset($this->form_id)) {

      if (is_array($this->description)) {
        $this->description_format = $this->description['format'];
        $this->description = $this->description['value'];
      }

      $params = array(
        'title' => $this->title,
        'description' => $this->description,
        'start_date' => $this->start_date,
        'end_date' => $this->end_date,
        'organizer_id' => $this->organizer_id,
        'status' => $this->status,
        'modified' => REQUEST_TIME,
      );

      if (!empty($this->is_new)) {
        $params['created'] = $params['modified'] = REQUEST_TIME;
      }
      
      if ($this->venue_id) {
        $params['venue_id'] = $this->venue_id;
      }
      
      if ($this->capacity) {
        $params['capacity'] = $this->capacity;
      }

      if ($this->personalized_url) {
        $params['personalized_url'] = $this->personalized_url;
      }

      $params['status'] = $this->status ? 'live' : 'draft';
      
      $params['hide'] = $this->status ? 'y' : 'n';

      if ($this->event_id) {
        $params['id'] = $this->event_id;
      }
dpm($params);
      $api_callback = !empty($this->is_new) && $this->venue_id ? 'event_new' : 'event_update';

      // $result = eventbrite_save($api_callback, $params);
// 
      // if (!$result || $result->process->status !== 'OK') {
        // return;
      // }

      if (!empty($this->is_new)) {
        drupal_set_message(t('This event has been created on the Eventbrite server.'));
      }
      else {
        drupal_set_message(t('This event has been updated on the Eventbrite server.'));
      }

//      $this->event_id = $result->process->id;

      foreach ($this->tickets[LANGUAGE_NONE] as $delta=>$ticket) {
        $params = array(
          'title' => $ticket['is_donation'],
          'name' => $ticket['name'],
          'description' => $ticket['description'],
          'quantity_available' => $ticket['quantity_available'],
          'start_date' => $ticket['start_date'] . ':00',
          'end_date' => $ticket['end_date'] . ':00',
          'include_fee' => $ticket['include_fee'],
          'min' => $ticket['min'],
          'hide ' => $ticket['hide'],
        );

        if ($ticket['max'] > 0) {
          $params['max'] = $ticket['max'];
        }
        
        if ($ticket['ticket_id'] > 0) {
          $params['ticket_id'] = $ticket['ticket_id'];
          
          $api_callback = 'ticket_update';
        }
        else {
          $api_callback = 'ticket_new';
        }
        dpm($params);
        // $result = eventbrite_save($api_callback, $params);
        
        // if (!$result || $result->process->status !== 'OK') {
          // return;
        // }
      
//        $this->$tickets[LANGUAGE_NONE][$delta]['ticket_id'] = $result->process->id;
      }

//      dpm($result);
    }


    dpm($this);
//
//    dpm(eventbrite_get('organizer_get', $params));

    parent::save();
//    // Update the static cache from profile2_load_by_user().
//    $cache = &drupal_static('profile2_load_by_user', array());
//    if (isset($cache[$this->uid])) {
//      $cache[$this->uid][$this->type] = $this->pid;
//    }
  }
}



/**
 * Eventbrite venue loader.
 *
 * @param $id
 *   (optional) The internal id for this venue. If no id is given all existing
 *   venues are returned.
 *
 * @return EventbriteVenue
 *   Returns a fully-loaded Eventbrite venue definition.
 */
function eventbrite_venue_load($id) {
  return entity_load_single('eventbrite_venue', $id);
}

/**
 * Load multiple Eventbrite venue entities based on certain conditions.
 *
 * @param $ids
 *   An array of Eventbrite venue internal IDs of Drupal.
 * @param $conditions
 *   An array of conditions to match against the {entity} table.
 * @param $reset
 *   A boolean indicating that the internal cache should be reset.
 *
 * @return
 *   An array of venue entities, indexed by venue ID.
 */
function eventbrite_venue_load_multiple($ids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('eventbrite_venue', $ids, $conditions, $reset);
}

/**
 * Create a Eventbrite venue object.
 */
function eventbrite_venue_create($values = array()) {
  if (is_object($values)) {
    $values = (array) $values;
  }

  return entity_get_controller('eventbrite_venue')->create($values);
}

/**
 * Saves an Eventbrite venue to the database.
 *
 * @param EventbriteVenue $venue
 *   The venue object.
 */
function eventbrite_venue_save(EventbriteVenue $venue) {
  return $venue->save();
}

/**
 * The class used for Eventbrite organizer entities.
 */
class EventbriteVenue extends Entity {

  public $venue_id;
  public $organizer_id;
  public $name;
  public $address;
  public $address_2;
  public $city;
  public $region;
  public $postal_code;
  public $country_code;
  public $status;

  public function defaultLabel() {
    return $this->name;
  }

  /**
   * Overrides Entity::save().
   */
  public function save() {
    // Only save data remotely to Eventbrite in a form submission 
    if (isset($this->form_id)) {

      $params = array(
        'name' => $this->name,
        'address' => $this->address,
        'address_2' => $this->address_2,
        'city' => $this->city,
        'region' => $this->region,
        'postal_code' => $this->postal_code,
        'country_code' => $this->country_code,
      );

      if ($this->venue_id) {
        $params['id'] = $this->venue_id;
      }

      if (!empty($this->is_new)) {
        $params['organizer_id'] = $this->organizer_id;
      }

      $api_callback = !empty($this->is_new) && $this->venue_id ? 'venue_new' : 'venue_update';

      $result = eventbrite_save($api_callback, $params);

      if (!$result || $result->process->status !== 'OK') {
        return;
      }

      if (!empty($this->is_new)) {
        drupal_set_message(t('This venue has been created on the Eventbrite server.'));
      }
      else {
        drupal_set_message(t('This venue has been updated on the Eventbrite server.'));
      }

      $this->venue_id = $result->process->id;

      dpm($result);
    }


    dpm($this);
//
//    dpm(eventbrite_get('organizer_get', $params));

    parent::save();
//    // Update the static cache from profile2_load_by_user().
//    $cache = &drupal_static('profile2_load_by_user', array());
//    if (isset($cache[$this->uid])) {
//      $cache[$this->uid][$this->type] = $this->pid;
//    }
  }
}

/**
 * Eventbrite oganizer loader.
 *
 * @param $id
 *   (optional) The internal id for this organizer. If no id is given all existing
 *   organizers are returned.
 *
 * @return EventbriteOrganizer
 *   Returns a fully-loaded Eventbrite organizer if a id is passed.
 */
function eventbrite_organizer_load($id) {
  return entity_load_single('eventbrite_organizer', $id);
}

/**
 * Load multiple Eventbrite organizer entities based on certain conditions.
 *
 * @param $ids
 *   An array of Eventbrite organizer internal IDs of Drupal.
 * @param $conditions
 *   An array of conditions to match against the {entity} table.
 * @param $reset
 *   A boolean indicating that the internal cache should be reset.
 *
 * @return
 *   An array of organizer entities, indexed by organizer ID.
 */
function eventbrite_organizer_load_multiple($ids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('eventbrite_organizer', $ids, $conditions, $reset);
}

/**
 * Create a Eventbrite organizer object.
 */
function eventbrite_organizer_create($values = array()) {
  if (is_object($values)) {
    $values = (array) $values;
  }

  return entity_get_controller('eventbrite_organizer')->create($values);
}

/**
 * Saves an Eventbrite organizer to the database.
 *
 * @param EventbriteOrganizer $organizer
 *   The organizer object.
 */
function eventbrite_organizer_save(EventbriteOrganizer $organizer) {
  return $organizer->save();
}

/**
 * The class used for Eventbrite organizer entities.
 */
class EventbriteOrganizer extends Entity {

  public $organizer_id;
  public $status;
  public $name;
  public $url;
  public $description;

  public function defaultLabel() {
    return $this->name;
  }

  /**
   * Overrides Entity::save().
   */
  public function save() {
    // Only save data remotely to Eventbrite in a form submission 
    if (isset($this->form_id)) {
      $params = array(
        'name' => $this->name,
        'description' => $this->description,
      );

      if ($this->organizer_id) {
        $params['id'] = $this->organizer_id;
      }

      $api_callback = !empty($this->is_new) && $this->organizer_id ? 'organizer_new' : 'organizer_update';

      $result = eventbrite_save($api_callback, $params);

      if (!$result || $result->process->status !== 'OK') {
        return;
      }

      $this->organizer_id = $result->process->id;

      dpm($result);
    }

    $this->status = 1;

//
//    dpm(eventbrite_get('organizer_get', $params));

    parent::save();
//    // Update the static cache from profile2_load_by_user().
//    $cache = &drupal_static('profile2_load_by_user', array());
//    if (isset($cache[$this->uid])) {
//      $cache[$this->uid][$this->type] = $this->pid;
//    }
  }
}

function eventbrite_get_options($type) {
  $cache = &drupal_static(__FUNCTION__);
  
  if (!in_array($type, array('venue', 'organizer'))) {
    return array();
  }
  
  if (!isset($cache[$type])) {
    if ($type == 'venue') {
      $options = array('' => t('TBA'));
    }
    else {
      $options = array();
    }

    $result = db_select('eventbrite_' . $type, 'e')
      ->fields('e', array($type . '_id', 'name'))
      ->condition('e.status', 1)
      ->orderBY('e.name', 'ASC')
      ->execute()
      ->fetchAllKeyed();

    if ($result) {
      $options += $result;
    }

    $cache[$type] = empty($options) ? array() : $options;
  }
  
  return $cache[$type];
}


