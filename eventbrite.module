<?php

/**
 * @file
 * Eventbrite module.
 */

define('EVENTBRITE_URL_ORG', 'http://www.eventbrite.com/org');


/**
 * Implements hook_libraries_info().
 */
function eventbrite_libraries_info() {
  // A very simple library. No changing APIs (hence, no versions), no variants. 
  $libraries['eventbrite.php'] = array(
    'name' => 'PHP Eventbrite API Client Library',
    'vendor url' => 'http://developer.eventbrite.com/doc/libraries',
    'download url' => 'https://github.com/ryanjarvinen/eventbrite.php.git',
    'files' => array(
      'php' => array('Eventbrite.php'),
    ),
    'version' => '1.0',
    'error message' => t('Download PHP Eventbrite API Client Library'),
  );

  return $libraries;
}

/**
 * Implements hook_init().
 */
function eventbrite_init() {
  drupal_add_css(drupal_get_path('module', 'eventbrite') . '/eventbrite.css');
}

/*
 * Implements of hook_menu().
 *
 *
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function eventbrite_menu() {

  $items['admin/config/services/eventbrite'] = array(
    'title' => 'Eventbrite Configuration',
    'description' => 'Configure Eventbrite settings & objects',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('eventbrite_admin_settings'),
    'access arguments' => array('administer eventbrite settings'),
    'file' => 'eventbrite.admin.inc',
  );

  $items['admin/config/services/eventbrite/api'] = array(
    'title' => 'API Settings',
    'description' => 'Configure Eventbrite API settings',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -1,
  );

//  $items['admin/config/services/eventbrite/organizers'] = array(
//    'title' => 'Organizers',
//    'description' => 'List Eventbrite organizers',
//    'page callback' => 'drupal_get_form',
//    'page arguments' => array('eventbrite_organizer_list_form'),
//    'access callback' => 'user_access',
//    'access arguments' => array('administer eventbrite settings'),
//    'file' => 'eventbrite.organizer.inc',
//    'type' => MENU_LOCAL_TASK,
//    'weight' => 2,
//  );

  // $items['admin/config/services/eventbrite/organizers/list'] = array(
  //   'title' => 'List Organizers',
  //   'description' => 'List Eventbrite organizers',
  //   'access callback' => 'user_access',
  //   'access arguments' => array('administer eventbrite settings'),
  //   'type' => MENU_DEFAULT_LOCAL_TASK,
  //   'weight' => 0,
  // );

  // $items['admin/config/services/eventbrite/organizers/add'] = array(
  //   'title' => 'Add an Organizer',
  //   'page callback' => 'drupal_get_form',
  //   'page arguments' => array('eventbrite_organizer'),
  //   'access callback' => 'user_access',
  //   'access arguments' => array('administer eventbrite settings'),
  //   'file' => 'eventbrite.organizer.inc',
  //   'type' => MENU_LOCAL_TASK,
  //   'weight' => 2,
  // );

  // $items['admin/config/services/eventbrite/organizers/%'] = array(
  //   'title' => 'Edit this Organizer',
  //   'description' => 'Edit an Eventbrite organizer',
  //   'page callback' => 'drupal_get_form',
  //   'page arguments' => array('eventbrite_organizer', 4),
  //   'access callback' => 'is_numeric',
  //   'access arguments' => array(4),
  //   'file' => 'eventbrite.organizer.inc',
  //   'type' => MENU_LOCAL_TASK,
  //   'weight' => 3,
  // );

  // // VENUES

   $items['admin/config/services/eventbrite/venues'] = array(
     'title' => 'Venues',
     'description' => 'List Eventbrite venues',
     'page callback' => 'drupal_get_form',
     'page arguments' => array('eventbrite_venue_list_form'),
     'access callback' => 'user_access',
     'access arguments' => array('administer eventbrite settings'),
     'file' => 'eventbrite.venue.inc',
     'type' => MENU_LOCAL_TASK,
     'weight' => 2,
   );

  // $items['admin/config/services/eventbrite/venues/list'] = array(
  //   'title' => 'List Venues',
  //   'description' => 'List Eventbrite venues',
  //   'access callback' => 'user_access',
  //   'access arguments' => array('administer eventbrite settings'),
  //   'type' => MENU_DEFAULT_LOCAL_TASK,
  //   'weight' => 0,
  // );

  // $items['admin/config/services/eventbrite/venues/add'] = array(
  //   'title' => 'Add a Venue',
  //   'page callback' => 'drupal_get_form',
  //   'page arguments' => array('eventbrite_venue'),
  //   'access callback' => 'user_access',
  //   'access arguments' => array('administer eventbrite settings'),
  //   'file' => 'eventbrite.venue.inc',
  //   'type' => MENU_LOCAL_TASK,
  //   'weight' => 2,
  // );

  // $items['admin/config/services/eventbrite/venues/%'] = array(
  //   'title' => 'Edit this Venue',
  //   'description' => 'Edit an Eventbrite venue',
  //   'page callback' => 'drupal_get_form',
  //   'page arguments' => array('eventbrite_venue', 4),
  //   'access callback' => 'is_numeric',
  //   'access arguments' => array(4),
  //   'file' => 'eventbrite.venue.inc',
  //   'type' => MENU_LOCAL_TASK,
  //   'weight' => 3,
  // );

  // $items['admin/config/services/eventbrite/payment-settings'] = array(
  //   'title' => 'Payment Settings',
  //   'description' => 'Configure default payment settings',
  //   'page callback' => 'drupal_get_form',
  //   'page arguments' => array('eventbrite_payment_default_settings'),
  //   'access callback' => 'user_access',
  //   'access arguments' => array('administer site configuration'),
  //   'file' => 'eventbrite.payment.inc',
  //   'type' => MENU_LOCAL_TASK,
  //   'weight' => 5,
  // );

  return $items;
}

/**
 * Implements hook_entity_info().
 */
function eventbrite_entity_info() {
//  $return['eventbrite_event'] = array(
//    'label' => t('Eventbrite Event'),
//    'entity class' => 'Entity',
//    'controller class' => 'EntityAPIController',
//    'base table' => 'eventbrite_event',
//    'fieldable' => TRUE,
//    'exportable' => TRUE,
//    'entity keys' => array(
//      'id' => 'event_id',
//    ),
//    'view modes' => array(
//      'full' => array(
//        'label' => t('Full content'),
//        'custom settings' => FALSE,
//      ),
//      'teaser' => array(
//        'label' => t('Teaser'),
//        'custom settings' => TRUE,
//      ),
//    ),
//    'label callback' => 'entity_class_label',
//    'uri callback' => 'entity_class_uri',
//    'module' => 'eventbrite',
//  );

  $return['eventbrite_venue'] = array(
    'label' => t('Eventbrite Venue'),
    'entity class' => 'EventbriteVenue',
    'controller class' => 'EntityAPIController',
    'base table' => 'eventbrite_venue',
    'fieldable' => TRUE,
//    'view modes' => array(
//      'full' => array(
//        'label' => t('Full content'),
//        'custom settings' => FALSE,
//      ),
//      'teaser' => array(
//        'label' => t('Teaser'),
//        'custom settings' => TRUE,
//      ),
//    ),
    'bundles' => array(
      'eventbrite_venue' => array(
        'label' => t('Eventbrite Venue'),
        'admin' => array(
          'path' => 'admin/config/services/eventbrite/venues2',
          'access arguments' => array('administer eventbrite venues'),
        ),
      ),
    ),
    'entity keys' => array(
      'id' => 'venue_id',
      'label' => 'name',
    ),
    'label callback' => 'entity_class_label',
    'uri callback' => 'entity_class_uri',
    'module' => 'eventbrite',
    // Enable the entity API's admin UI.
    'admin ui' => array(
      'path' => 'admin/config/services/eventbrite/venues2',
      'file' => 'eventbrite.venue.inc',
      'controller class' => 'EventbriteVenueUIController',
    ),
    'access callback' => 'eventbrite_access',
  );

  $return['eventbrite_organizer'] = array(
    'label' => t('Eventbrite Organizer'),
    'entity class' => 'EventbriteOrganizer',
    'controller class' => 'EntityAPIController',
    'base table' => 'eventbrite_organizer',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'id',
      'label' => 'name',
    ),
//    'bundles' => array(
//      'eventbrite_organizer' => array(
//        'label' => t('Eventbrite Organizer'),
//      ),
//    ),
//    'view modes' => array(
//      'full' => array(
//        'label' => t('Full content'),
//        'custom settings' => FALSE,
//      ),
//      'teaser' => array(
//        'label' => t('Teaser'),
//        'custom settings' => TRUE,
//      ),
//    ),
    'label callback' => 'entity_class_label',
    'uri callback' => 'entity_class_uri',
    'module' => 'eventbrite',
    // Enable the entity API's admin UI.
    'admin ui' => array(
      'path' => 'admin/config/services/eventbrite/organizers',
      'file' => 'eventbrite.organizer.inc',
      'controller class' => 'EventbriteOrganizerUIController',
    ),
    'access callback' => 'eventbrite_access',
  );

  return $return;
}

/**
 * Implements hook_menu_alter()
 */
function eventbrite_menu_alter(&$items) {
  if (isset($items['admin/config/services/eventbrite/venue2'])) {
    $items['admin/config/services/eventbrite/venue2']['type'] = MENU_LOCAL_TASK;
  }
}

/**
 * Implements hook_permissions().
 */
function eventbrite_permission() {
  return array(
    'administer eventbrite settings' => array(
      'title' => t('administer eventbrite settings'),
      'description' => t('Gives full control over the eventbrite admin page'),
    ),
    'administer eventbrite venues' => array(
      'title' => t('administer eventbrite venues'),
      'description' => t('allows users to configure eventbrite venues'),
    ),
  );
}

/**
 * Access check for Eventbrite admin UI page
 */
function eventbrite_access($op, $entity = NULL, $account = NULL, $entity_type) {
  switch ($entity_type) {
     case 'eventbrite_venue':
       return user_access('administer eventbrite venues', $account);
     
     case 'eventbrite_organizer':
       return user_access('administer eventbrite settings', $account);
   }

  // if ($op == 'create' || $op == 'update') {
  //   $op = 'edit';
  // }
  // Allow modules to grant / deny access.
  return FALSE;
}


/**
 * Implements hook_theme().
 */
function eventbrite_theme() {
  return array(
    'eventbrite_venue_list_form' => array(
      'render element' => 'form',
      'file' => 'eventbrite.venue.inc',
    ),
//    'eventbrite_organizer_list_form' => array(
//      'render element' => 'form',
//      'file' => 'eventbrite.organizer.inc',
//    ),
  );
}

/**
 * Implements hook_flush_caches().
 */
function eventbrite_flush_caches() {
  return array('cache_eventbrite');
}

/* API FUNCTIONS EXPOSED TO OTHER MODULES */

/**
 * Get $eb_client instance
 */
function eventbrite_get_object($app_key = '', $user_key = '') {
  static $eb_client;

  if (empty($eb_client) && eventbrite_is_valid_auth()) {
        
    libraries_load('eventbrite.php');

    $authentication_tokens = array(
      'app_key'  => $app_key ? $app_key : variable_get('eventbrite_app_key', ''),
      'user_key' => $user_key ? $user_key : variable_get('eventbrite_user_key', ''),
    );

    $eb_client = new Eventbrite($authentication_tokens); 
  }

  return $eb_client;
}

/**
 * Allows a get-oriented operation to called via the Eventbrite API
 *
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function eventbrite_get($op, $params = NULL, $reset = FALSE) {
  $result = array();

  $eb_client = eventbrite_get_object();

  if (!$eb_client) {
    return FALSE;
  }

  $valid_callbacks = array(
    // Events
    'event_get',
    // Organizers
    'organizer_get',
    // Users
    'user_list_events',
    'user_list_venues',
    'user_list_organizers',
    'user_get',
  );

  if (!in_array($op, $valid_callbacks)) {
    drupal_set_message('Eventbrite get operation is not valid', 'error');
    watchdog('eventbrite', t('Eventbrite get operation is not valid'), NULL, WATCHDOG_ERROR);
    return;
  }


  $user_key = variable_get('eventbrite_user_key', '');
  $cid = $op . ':' . $user_key;
  $cache = FALSE;

  if ($reset) {
    clear_cache_all($cid, 'cache_eventbrite');
  }
  else {
    $cache = cache_get($cid, 'cache_eventbrite');
  }

  if ($cache !== FALSE && REQUEST_TIME <= $cache->expire) {
    $result = $cache->data;
  }
  else {
    try{
      $result = $eb_client->$op($params);
    } catch (Exception $e) {
      drupal_set_message('Eventbrite API call failed. Error message:' . "\n" . $e->getMessage(), 'error');
      watchdog('eventbrite', 'Eventbrite API call failed. Error message:' . "\n" . $e->getMessage(), NULL, WATCHDOG_ERROR);
      return;
    }

    if (strpos($op, 'user_list') !== FALSE) {
      $plural_label = substr($op, 10);
      $label = substr($op, 10, -1);
      $data = array();

      foreach ($result->$plural_label as $object) {
        $entry = $object->$label;
        $id_key = $label . '_id';

        $entry->$id_key = (string) $entry->id;

        unset($entry->id);

        $data[$entry->$id_key] = $entry;
      }

      $result = $data;

      module_invoke_all('eventbrite_' . $op, $result);

      $expire = 60 * variable_get('eventbrite_cache_minimum', 5);

      cache_set($cid, $data, 'cache_eventbrite', REQUEST_TIME + $expire);
    }
  }

  return $result;
}

/**
 * Implements hook_eventbrite_user_list_organizers()
 */
function eventbrite_eventbrite_user_list_organizers($result) {

  $remote_organizer_ids = $result;
  $organizer_ids = db_query('SELECT organizer_id, id FROM {eventbrite_organizer}')->fetchAllKeyed();

  $new_organizer_ids = array_diff_key($remote_organizer_ids, $organizer_ids);

  $update_organizer_ids = array_intersect_key($organizer_ids, $remote_organizer_ids);

  foreach($new_organizer_ids as $organizer_id => $entry) {
    $organizer = eventbrite_organizer_create($entry);

    eventbrite_organizer_save($organizer);
  }

  foreach($update_organizer_ids as $organizer_id => $entity_id) {
    $organizer = eventbrite_organizer_load($entity_id);
    $entry = $result[$organizer_id];

    $organizer->name = $entry->name;
    $organizer->description = $entry->description;

    eventbrite_organizer_save($organizer);
  }
}

/*
 * Allows a save-oriented operation to called via the Eventbrite API
 */
/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function eventbrite_save($op, $params) {
  $result = array();

  $eb_client = eventbrite_get_object();

  if (!$eb_client) {
    return FALSE;
  }

  $valid_callbacks = array(
    // Events
    'event_new',
    'event_update',
    // Tickets
    'ticket_new',
    'ticket_update',
    // Venues
    'venue_new',
    'venue_update',
    // Organizer Profiles
    'organizer_new',
    'organizer_update',
    // Users
    'user_new',
    // Payments
    'payment_update',
  );

  if (in_array($op, $valid_callbacks)) {
    try{
      $result = $eb_client->$op($params);
    } catch (Exception $e) {
      drupal_set_message('Eventbrite API call failed. Error message:' . "\n" . $e->getMessage(), 'error');
      watchdog('eventbrite', 'Eventbrite API call failed. Error message:' . "\n" . $e->getMessage(), NULL, WATCHDOG_ERROR);
    }
  }
  else {
    drupal_set_message('Eventbrite save operation is not valid', 'error');
    watchdog('eventbrite', t('Eventbrite save operation is not valid'), NULL, WATCHDOG_ERROR);
  }

  return $result;
}

/**
 * Synchronize local data with remote Eventbrite data
 */
function eventbrite_sync($op) {
  eventbrite_get($op);
}

/*
 * This function translates offset into the formatting that Eventbrite API is expecting
 */
/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function eventbrite_timezone_offset($offset) {
  $eb_timezone = 'GMT';
  $eb_timezone .= ($offset < 0) ? '-' : '+';
  $eb_timezone .= (abs($offset) >= 10) ? abs($offset) : '0' . abs($offset);

  return $eb_timezone;
}

/**
 * Returns Eventbrite's API user_list_events as a keyed array suitable
 * for option lists.
 *
 * @param mixed $id
 *   The event id for an event that must not be filtered.
 * @param boolean $allow_historical
 *   Whether or not events that start prior to the current time should
 *   be returned.
 * @return array
 *   An array of events keyed by event id and containing event titles.
 */
function eventbrite_get_events_options($id = null, $allow_historical = false) {
  $options = array();
  if ($events = eventbrite_get('user_list_events')) {
    $options[0] = '';
    foreach ($events as $event_id => $event) {
      if (($id == $event_id) || $allow_historical) {
        $options[$event_id] = $event->title;
      }
      else {
        $start_date_ts = date_convert($event->start_date, DATE_DATETIME, DATE_UNIX, $event->timezone);
        if ($start_date_ts > REQUEST_TIME) {
          $options[$event_id] = $event->title;
        }
      }
    }
  }
  return $options;
}

/*
 * This function returns TRUE if Eventbrite module is set up with valid Eventbrite authentication
 */
/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function eventbrite_is_valid_auth() {
  return variable_get('eventbrite_is_valid_auth', FALSE);
}


/**
 * OG membership loader.
 *
 * @param $name
 *   (optional) The name for this group membership. If no type is given all existing
 *   types are returned.
 *
 * @return OgMembership
 *   Returns a fully-loaded group membership definition if a type name is passed.
 *   Else an array containing all types is returned.
 */
function eventbrite_organizer_load($id) {
  return entity_load_single('eventbrite_organizer', $id);
}

/**
 * Load multiple OG membership entities based on certain conditions.
 *
 * @param $gids
 *   An array of group membership IDs.
 * @param $conditions
 *   An array of conditions to match against the {entity} table.
 * @param $reset
 *   A boolean indicating that the internal cache should be reset.
 *
 * @return
 *   An array of group entities, indexed by group ID.
 */
function eventbrite_organizer_load_multiple($ids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('eventbrite_organizer', $ids, $conditions, $reset);
}

/**
 * Create a organizer object.
 */
function eventbrite_organizer_create($values = array()) {
  if (is_object($values)) {
    $values = (array) $values;
  }

  return entity_get_controller('eventbrite_organizer')->create($values);
}

/**
 * Saves an organizer to the database.
 *
 * @param EventbriteOrganizer $organizer
 *   The organizer object.
 */
function eventbrite_organizer_save(EventbriteOrganizer $organizer) {
  return $organizer->save();
}

/**
 * The class used for Eventbrite organizer entities.
 */
class EventbriteVenue extends Entity {

  public $venue_id;
  public $organizer_id;
  public $name;
  public $address;
  public $address2;
  public $city;
  public $region;
  public $postal_code;
  public $country;
  public $status;

  public function defaultLabel() {
    return $this->name;
  }

  /**
   * Overrides Entity::save().
   */
  public function save() {
    // Care about setting created and changed values. But do not automatically
    // set a created values for already existing profiles.
//    if (empty($this->created) && (!empty($this->is_new) || !$this->pid)) {
//      $this->created = REQUEST_TIME;
//    }
//    $this->changed = REQUEST_TIME;

    $params = array(
      'organizer_id' => $this->organizer_id,
      'name' => $this->name,
      'address' => '',
      'address_2' => '',
      'city' => '',
      'region' => '',
      'postal_code' => '',
      'country_code' => '',
    );

    if ($this->venue_id) {
      $params['id'] = $this->venue_id;
    }

    $api_callback = !empty($this->is_new) ? 'venue_new' : 'venue_update';

    $result = eventbrite_save($api_callback, $params);

    if ($result->process->status === 'OK') {

      if (!empty($this->is_new)) {
        drupal_set_message(t('This organizer has been created on the Eventbrite server.'));
      }
      else {
        drupal_set_message(t('This organizer has been updated on the Eventbrite server.'));
      }

      $this->venue_id = (string) $result->process->id;
    }

    dpm($result);
    dpm($this);
//
//    dpm(eventbrite_get('organizer_get', $params));

    parent::save();
//    // Update the static cache from profile2_load_by_user().
//    $cache = &drupal_static('profile2_load_by_user', array());
//    if (isset($cache[$this->uid])) {
//      $cache[$this->uid][$this->type] = $this->pid;
//    }
  }
}

/**
 * The class used for Eventbrite organizer entities.
 */
class EventbriteOrganizer extends Entity {

  public $organizer_id;
  public $status;
  public $name;
  public $url;
  public $description;

  public function defaultLabel() {
    return $this->name;
  }

  /**
   * Overrides Entity::save().
   */
  public function save() {
    // Care about setting created and changed values. But do not automatically
    // set a created values for already existing profiles.
//    if (empty($this->created) && (!empty($this->is_new) || !$this->pid)) {
//      $this->created = REQUEST_TIME;
//    }
//    $this->changed = REQUEST_TIME;

    // Only save data remotely to Eventbrite in a form submission 
    if (isset($this->form_id)) {
      $params = array(
        'name' => $this->name,
        'description' => $this->description,
      );

      if ($this->organizer_id) {
        $params['id'] = $this->organizer_id;
      }

      $api_callback = !empty($this->is_new) ? 'organizer_new' : 'organizer_update';

      $result = eventbrite_save($api_callback, $params);

      if ($result->process->status === 'OK') {
        $this->organizer_id = $result->process->id;
      }

      dpm($result);
    }

    $this->status = 1;

//
//    dpm(eventbrite_get('organizer_get', $params));

    parent::save();
//    // Update the static cache from profile2_load_by_user().
//    $cache = &drupal_static('profile2_load_by_user', array());
//    if (isset($cache[$this->uid])) {
//      $cache[$this->uid][$this->type] = $this->pid;
//    }
  }
}
